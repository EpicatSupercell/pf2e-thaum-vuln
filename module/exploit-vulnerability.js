import {EXPLOIT_VULNERABILITY_ACTION_ID, MORTAL_WEAKNESS_EFFECT_SOURCEID, MORTAL_WEAKNESS_EFFECT_UUID, PERSONAL_ANTITHESIS_EFFECT_SOURCEID,
		PERSONAL_ANTITHESIS_EFFECT_UUID, FLAT_FOOTED_EFFECT_UUID, MORTAL_WEAKNESS_TARGET_SOURCEID, PERSONAL_ANTITHESIS_TARGET_SOURCEID,
		MORTAL_WEAKNESS_TARGET_UUID, PERSONAL_ANTITHESIS_TARGET_UUID} from "./utils.js";
import {createEffectOnTarget, updateEVEffect} from "./socket.js";


//Creates the dialog box when a success or crit success on Esoteric Lore is rolled
export function createEVDialog(sa, t, paEffectSource, mwEffectSource, iwrContent) {
	const aLevel = sa.level;
	const paDmg = 2 + Math.floor(aLevel / 2);
	return new Dialog({
		title: "Exploit Vulnerability",
		content: html => "<p>Choose whether to exploit a Personal Antithesis or Mortal Weakness</p><br>" + iwrContent + `<p>Personal Antithesis Bonus Damage: ${paDmg}</p>`,
		buttons: {
			pa: {
				label: "Personal Antithesis",
				callback: () => {createEffectOnActor(sa, t, paEffectSource);}
			},
			mw: {
				label: "Mortal Weakness",
				callback: () => {createEffectOnActor(sa, t, mwEffectSource);}
			}
		},
		default: "pa",
		render: html => console.log("Register interactivity in the rendered dialog"),
		close: html => console.log("This always is logged no matter which option is chosen")
	});
}

//Creates the passed effect document on the actor
export async function createEffectOnActor(sa, t, effect) {
	let eff = effect.toObject();
	let creatureType;
	let evMode;
	if(eff.flags.core.sourceId === MORTAL_WEAKNESS_EFFECT_SOURCEID) {
		if(t.actor.system?.attributes?.weaknesses) {
			if(t.actor.system?.attributes?.weaknesses == ''){return ui.notifications.warn("There are no weaknesses on this creature to exploit a Mortal Weakness against.");}
			createEffectOnTarget(sa, t, effect);
		} else if(t.document.actorData.system?.attributes?.weaknesses) {
			if(t.document.actorData.system?.attributes?.weaknesses == ''){return ui.notifications.warn("There are no weaknesses on this creature to exploit a Mortal Weakness against.");}
			createEffectOnTarget(sa, t, effect);
		}

		if(t.actor.system.details.creatureType == ''){
			creatureType = "exploit-vulnerability";
		} else {
			creatureType = t.actor.system.details.creatureType.toLowerCase();
		}
		evMode = "mortal-weakness";

	} else if (eff.flags.core.sourceId === PERSONAL_ANTITHESIS_EFFECT_SOURCEID){
		evMode = "personal-antithesis";
		createEffectOnTarget(sa, t, effect);
	}
	await sa.setFlag("pf2e-thaum-vuln", "activeEV", true);
	await sa.setFlag("pf2e-thaum-vuln", "EVTargetID", `${t.actor.uuid}`);
	await sa.setFlag("pf2e-thaum-vuln", "EVTargetType", `${creatureType}`);
	await sa.setFlag("pf2e-thaum-vuln", "EVMode", `${evMode}`);	
	await sa.createEmbeddedDocuments('Item', [eff]);
}

//Gets the effects of Personal Antithesis or Mortal Weakness from the character
export async function getActorEffects(sa){
	return sa.items.find(item => item.getFlag("core", "sourceId") === PERSONAL_ANTITHESIS_EFFECT_SOURCEID || item.getFlag("core", "sourceId") === MORTAL_WEAKNESS_EFFECT_SOURCEID );
}

//Gets the highest IWR value from an array that is passed in
export function getGreatestIWR(iwr) {
	if (iwr) {
		let gIWR = iwr[0];
		for(const n of iwr) {
			if(n.value >= gIWR.value) {
				gIWR = n;
			}
		}
		return gIWR;
	} 
}

//Creates the IWR content box content
export function createIWRContent(rollDOS, w, r, i) {
	let iwrContent;
	if(w == ''){w = false;}
	if(r == ''){r = false;}
	if(i == ''){i = false;}
	if(rollDOS === 2) {
		let weakness = !w ? "None" : `${getGreatestIWR(w).type} - ${getGreatestIWR(w).value}`;
		iwrContent = `<p>Highest Weakness: ${weakness}</p>`;
	}
	if(rollDOS === 3) {
		let weakness = !w ? "None" : stitchIWR(w);
		let resist = !r ? "None" : stitchIWR(r);
		let immune = !i ? "None" : stitchIWR(i);
		iwrContent = `<div class="grid-container"><div class="grid-item"><p>Weaknesses: <ul>${weakness}</ul></p></div><div class="grid-item"><p>Resistances: <ul>${resist}</ul></p></div><div class="grid-item"><p>Immunities: <ul>${immune}</ul></p></div></div>`;
	}
	return iwrContent;
}

//stitches together the IWR information to help create the content for the dialog box
export function stitchIWR(p) {
	let s = "";
	for(const n of p){
		if(n.value){
			s = s + `<li>${n.type} - ${n.value}</li>`;
			if(n.exceptions.length != 0) {
				s = s + "Except: ";
				for(const e of n.exceptions) {
					if(e === n.exceptions[n.exceptions.length - 1]) {
						s = s + `${e}`;
					} else {s = s + `${e}, `;}
				}
				s = s + "<br>";
			}
			if(n.doubleVs == ''){n.doubleVs = false;}
			if(n.doubleVs) {
				s = s + "Double vs.: "
				for(const d of n.doubleVs) {
					if(d === n.doubleVs[n.doubleVs.length - 1]) {
						s = s + `${d}`;
					} else {s = s + `${d}, `;}
				}
			}
		} else {
			s = s + `<li>${n.type}</li>`;
			if(n.exceptions.length != 0) {
				s = s + "Except: ";
				for(const e of n.exceptions) {
					if(e === n.exceptions[n.exceptions.length - 1]) {
						s = s + `${e}`;
					} else {s = s + `${e}, `;}
				}
			}
		}
	}
	return s;
}

export async function exploitVuln() {
	const DCByLevel = [13, 14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34, 35, 36, 38, 39, 40, 42, 44, 46, 48, 50];
	const skillName = "Esoteric Lore";
	const skillKey = "esoteric-lore";
	const actionSlug = "action:recall-knowledge"
	const actionName = "Recall Knowledge"
	
	//grab the selected token and the targeted token
	const a = canvas.tokens.controlled;
	let ts = Array.from(game.user.targets);
	
	//make sure we're only targeting one target and have the thaum selected
	if (a.length != 1 || ts.length != 1){
		return ui.notifications.warn("Select one token and target one creature.")
	}
	
	//set the first index in the array as the target and the first controlled token actor as selected actor
	const t = Array.from(ts)[0];
	const sa = a[0].actor;
	//check for exploit vulnerability on the actor
	const exploitVulnAction = sa.items.find(item => item.getFlag("core", "sourceId") === EXPLOIT_VULNERABILITY_ACTION_ID);
	if (!exploitVulnAction) {
		return ui.notifications.warn(`${a[0].actor.name} does not have the ability to Exploit Vulnerability`);
	}
	
	//Exploit Vulnerability Effect/action - Tikael's macro code
	await exploitVulnAction.toMessage();
	const modifiers = [];
	let DC = DCByLevel[t.actor.system.details.level.value+1];
	const notes = [...sa.system.skills[skillKey].notes];

	const options = sa.getRollOptions(['all', 'skill-check', skillName.toLowerCase()]);
	options.push(`action:${actionSlug}`);

	let evRoll = await game.pf2e.Check.roll(
		new game.pf2e.CheckModifier(
			`<span class="pf2-icon">A</span> <b>${actionName}</b> - <p class="compact-text">${skillName } Skill Check</p>`,
			sa.system.skills[skillKey], modifiers), {
			actor: sa.actor,
			type: 'skill-check',
			options,
			notes,
			dc: {
			value: DC
			}
		},
		event
	);
	
	//deletes Exploit Vulnerability effect if it already exists on the actor
	let evExistingEffect = await getActorEffects(sa);
	if(evExistingEffect) {
		evExistingEffect.delete();
	}

	const paEffectSource = await fromUuid(PERSONAL_ANTITHESIS_EFFECT_UUID);
	const mwEffectSource = await fromUuid(MORTAL_WEAKNESS_EFFECT_UUID);
	const flatFootedEffect = await fromUuid(FLAT_FOOTED_EFFECT_UUID);
	let tWeak, tRes, tImm;
	if(t.actor.system?.attributes?.weaknesses) {
		tWeak = t.actor.system?.attributes?.weaknesses;
	} else if(t.document.actorData.system?.attributes?.weaknesses) {
		tWeak = t.document.actorData.system?.attributes?.weaknesses;
	}
	if(t.actor.system?.attributes?.resistances) {
		tRes = t.actor.system?.attributes?.resistances;
	} else if(t.document.actorData.system?.attributes?.resistances) {
		tRes = t.document.actorData.system?.attributes?.resistances;
	}
	if(t.actor.system?.attributes?.immunities) {
		tImm = t.actor.system?.attributes?.immunities;
	} else if(t.document.actorData.system?.attributes?.immunities) {
		tImm = t.document.actorData.system?.attributes?.immunities;
	}
	
	let evDialog;
	const iwrContent = createIWRContent(evRoll.degreeOfSuccess, tWeak, tRes, tImm);

	//Apply effect based on Degrees of success
	switch(evRoll.degreeOfSuccess)
	{
		case 0:
			//critical failure. Apply flatfooted condition for one round.
			await sa.createEmbeddedDocuments('Item', [flatFootedEffect.toObject()]);
			break;
		case 1:
			//normal failure. Can only apply personal antithesis.
			await sa.createEmbeddedDocuments('Item', [paEffectSource.toObject()]);
			await createEffectOnTarget(sa, t, paEffectSource);
			break;
		case 2:
			//normal success. Learns highest weakness. Can apply Mortal Weakness or Personal Antithesis
			evDialog = createEVDialog(sa, t, paEffectSource, mwEffectSource, iwrContent)
			evDialog.render(true);
			break;
		case 3:
			//Critical success. Learns all weaknesses, resistances, and immunities including the amounts and any unusual weaknesses or vulnerabilities
			//Can apply Mortal Weakness or Personal Antithesis. 
			evDialog = createEVDialog(sa, t, paEffectSource, mwEffectSource, iwrContent)
			evDialog.render(true);
			break;
		default:
			return;
	}
}

export async function forceEVTarget(){
	const m = await fromUuid(MORTAL_WEAKNESS_TARGET_UUID);
	const p = await fromUuid(PERSONAL_ANTITHESIS_TARGET_UUID);
	let eff;
	
	let a = canvas.tokens.objects.children.find(token => token.actor?.getFlag("pf2e-thaum-vuln","activeEV") === true);
	console.log(a);
	let evM = a.actor.getFlag("pf2e-thaum-vuln","EVMode");
	let tID = a.actor.getFlag("pf2e-thaum-vuln","EVTargetID");
	let tar = Array.from(game.user.targets);
	if(evM === "mortal-weakness") {
		eff = m.toObject();
	} else if(evM === "personal-antithesis"){
		eff = p.toObject();
	} else {return}
	eff.system.rules[0].value = a.actor.getFlag("pf2e-thaum-vuln","EVValue");
	if(tar.length != 1) return ui.notifications.warn("Target only one token.");
	await tar[0].actor.createEmbeddedDocuments('Item', [eff]);
}

Hooks.on("renderChatMessage", (message) => {
	
	if(message.speaker.actor && (message.flags?.pf2e?.context?.type === "attack-roll")){
		let a = message.speaker.actor;
		if(canvas.initialized && canvas.tokens.objects.children.find(token => token.actor.id === a)){
			if(a == canvas.tokens.objects.children.find(token => token.actor.items.find(item => item.getFlag("core","sourceId") === MORTAL_WEAKNESS_EFFECT_SOURCEID ? item : item.getFlag("core","sourceId") ===  PERSONAL_ANTITHESIS_EFFECT_SOURCEID)).actor.id){
				updateEVEffect(a, true);
			} else {
				updateEVEffect(a, false);
			}
		}
	}
},{once:false});

