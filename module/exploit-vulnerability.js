import {EXPLOIT_VULNERABILITY_ACTION_ID, MORTAL_WEAKNESS_EFFECT_SOURCEID, MORTAL_WEAKNESS_EFFECT_UUID, PERSONAL_ANTITHESIS_EFFECT_SOURCEID,
		PERSONAL_ANTITHESIS_EFFECT_UUID, FLAT_FOOTED_EFFECT_UUID, MORTAL_WEAKNESS_TARGET_UUID, PERSONAL_ANTITHESIS_TARGET_UUID, BREACHED_DEFENSES_EFFECT_SOURCEID,
		ADJUSTMENT_TYPES, getActorEVEffect, createEVDialog, createIWRContent, BDGreatestBypassableResistance} from "./utils.js";
import {createEffectOnTarget, updateEVEffect, deleteEVEffect, createSecretMessage} from "./socket.js";


//Creates the passed effect document on the actor
export async function createEffectOnActor(sa, t, effect) {
	
	let eff = effect.toObject();
	let creatureType;
	let evMode;
	let evTargets = new Array;
	if (eff.flags.core.sourceId === MORTAL_WEAKNESS_EFFECT_SOURCEID) {
		if (t.actor.system?.attributes?.weaknesses) {
			if (t.actor.system?.attributes?.weaknesses == '') { return ui.notifications.warn("There are no weaknesses on this creature to exploit a Mortal Weakness against."); }
		} else if (t.document.actorData.system?.attributes?.weaknesses) {
			if (t.document.actorData.system?.attributes?.weaknesses == '') { return ui.notifications.warn("There are no weaknesses on this creature to exploit a Mortal Weakness against."); }
		}

		if (t.actor.system.details.creatureType == '') {
			creatureType = "exploit-vulnerability";
		} else {
			creatureType = t.actor.system.details.creatureType;
		}
		evMode = "mortal-weakness";

	} else if (eff.flags.core.sourceId === PERSONAL_ANTITHESIS_EFFECT_SOURCEID) {
		evMode = "personal-antithesis";

		//breached defenses logic. It mostly works... there are a few weird cases where it doesn't work such as when the highest
		//resistance that can be bypassed is a combination of two traits (see adamantine golem's resistance bypass from vorpal-adamantine)
		//or if the trait that bypasses it is not in the system/on my list
	} else if (eff.flags.core.sourceId === BREACHED_DEFENSES_EFFECT_SOURCEID) {
		evMode = "breached-defenses";
		const bypassable = BDGreatestBypassableResistance(t.actor.system?.attributes?.resistances);
		const exception = (() => {
			let property;
			for (const prop in ADJUSTMENT_TYPES) {
				for (const excp of ADJUSTMENT_TYPES[prop].data) {
					if (excp === bypassable.exceptions[0]) {
						property = ADJUSTMENT_TYPES[prop].propLabel;
					}
                }
            }
			return{
				property: property,
				exception: bypassable.exceptions[0]
			};
		})();
		eff.system.rules.find(rules => rules.slug === "breached-defenses-bypass").value = exception.exception;
		eff.system.rules.find(rules => rules.slug === "breached-defenses-bypass").property = exception.property;
		eff.system.rules.find(rules => rules.slug === "breached-defenses-bypass").predicate = (`target:effect:Breached Defenses Target ${sa.name}`).slugify();
	}

	evTargets.push(t.actor.uuid);

	createEffectOnTarget(sa, t, effect, evTargets);
	await sa.setFlag("pf2e-thaum-vuln", "activeEV", true);
	await sa.setFlag("pf2e-thaum-vuln", "EVTargetID", evTargets);
	await sa.setFlag("pf2e-thaum-vuln", "EVTargetType", `${creatureType}`);
	await sa.setFlag("pf2e-thaum-vuln", "EVMode", `${evMode}`);	
	await sa.createEmbeddedDocuments('Item', [eff]);
}

export async function exploitVuln() {
	const DCByLevel = [13, 14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34, 35, 36, 38, 39, 40, 42, 44, 46, 48, 50];
	const skillName = "Esoteric Lore";
	const skillSlug = skillName.slugify();
	const actionName = "Recall Knowledge";
	
	//grab the selected token and the targeted token
	const a = canvas.tokens.controlled;
	let ts = Array.from(game.user.targets);
	
	//make sure we're only targeting one target and have the thaum selected
	if (a.length != 1 || ts.length != 1){
		return ui.notifications.warn("Select one token and target one creature.")
	}
	
	//set the first index in the array as the target and the first controlled token actor as selected actor
	const t = Array.from(ts)[0];
	const sa = a[0].actor;
	
	//check for exploit vulnerability on the actor
	const exploitVulnAction = sa.items.find(item => item.getFlag("core", "sourceId") === EXPLOIT_VULNERABILITY_ACTION_ID);
	if (!exploitVulnAction) {
		return ui.notifications.warn(`${a[0].actor.name} does not have the ability to Exploit Vulnerability`);
	}
	
	//deletes Exploit Vulnerability effect if it already exists on the actor
	await deleteEVEffect(canvas.tokens.placeables, sa);
	
	//Exploit Vulnerability Effect/action - Trent's macro code
	let DC = DCByLevel[t.actor.level+1];

	let evRoll = await sa.skills[skillSlug].roll({
		dc: DC,
		target: t.actor,
		extraRollOptions: [`action:${actionName.slugify()}`]
	});

	//handle diverse lore
	if (sa.items.some(item => item.slug === "diverse-lore")) {
		const DLDC = t.actor.system.details.identification?.skill.dc;
		const DCDifference = evRoll.total - DLDC;
		let IDDOS;
		let DOSDetails;
		if (evRoll.degreeOfSuccess == 2 || evRoll.degreeOfSuccess == 3) {
			if (DCDifference <= -10) {
				IDDOS = "Critical Failure";
				DOSDetails = "The player recalls incorrect information or gains erroneous or misleading clues about the creature.";
			} else if (DCDifference < 0 && DCDifference >= -10) {
				IDDOS = "Failure";
				DOSDetails = "The player fails to recall knowledge about the creature. <h4>Dubious Knowledge<h4><p>The player receives a bit of true knowledge and a bit of erroneous knowledge.<p>";
			} else if (DCDifference >= 0 && DCDifference < 10) {
				IDDOS = "Success";
				DOSDetails = "The player recalls the knowledge accurately or gains a useful clue about the creature."
			} else if (DCDifference >= 10) {
				IDDOS = "Critical Success";
				DOSDetails = "The player recalls the knowledge accurately and gains additional information or context about the creature.";
			}
			let _a = game.users.find(u => u.isGM);
			await createSecretMessage(
				{
					blind: false,
					flavor: `<h4>Diverse Lore - Results</h4><h4>DC ${DLDC}</h4> <p>${IDDOS} by ${DCDifference}</p><br><p>${DOSDetails}</p>`,
					speaker: {
						alias: "Gamemaster"
					},
					whisper: [null === (_a) || void 0 === _a ? void 0 : _a.id]
				}
			);
		}
		
    }


	const paEffectSource = await fromUuid(PERSONAL_ANTITHESIS_EFFECT_UUID);
	const mwEffectSource = await fromUuid(MORTAL_WEAKNESS_EFFECT_UUID);
	const flatFootedEffect = await fromUuid(FLAT_FOOTED_EFFECT_UUID);
	let tWeak, tRes, tImm;
	if(t.actor.system?.attributes?.weaknesses) {
		tWeak = t.actor.system?.attributes?.weaknesses;
	} else if(t.document.actorData.system?.attributes?.weaknesses) {
		tWeak = t.document.actorData.system?.attributes?.weaknesses;
	}
	if(t.actor.system?.attributes?.resistances) {
		tRes = t.actor.system?.attributes?.resistances;
	} else if(t.document.actorData.system?.attributes?.resistances) {
		tRes = t.document.actorData.system?.attributes?.resistances;
	}
	if(t.actor.system?.attributes?.immunities) {
		tImm = t.actor.system?.attributes?.immunities;
	} else if(t.document.actorData.system?.attributes?.immunities) {
		tImm = t.document.actorData.system?.attributes?.immunities;
	}
	
	let evDialog;
	const iwrContent = createIWRContent(evRoll.degreeOfSuccess, tWeak, tRes, tImm);

	//Apply effect based on Degrees of success
	switch(evRoll.degreeOfSuccess)
	{
		case 0:
			//critical failure. Apply flatfooted condition for one round.
			await sa.createEmbeddedDocuments('Item', [flatFootedEffect.toObject()]);
			break;
		case 1:
			//normal failure. Can only apply personal antithesis.
			await createEffectOnActor(sa, t, paEffectSource);
			break;
		case 2:
			//normal success. Learns highest weakness. Can apply Mortal Weakness or Personal Antithesis
			evDialog = await createEVDialog(sa, t, paEffectSource, mwEffectSource, iwrContent, 2)
			evDialog.render(true);
			break;
		case 3:
			//Critical success. Learns all weaknesses, resistances, and immunities including the amounts and any unusual weaknesses or vulnerabilities
			//Can apply Mortal Weakness or Personal Antithesis. 
			evDialog = await createEVDialog(sa, t, paEffectSource, mwEffectSource, iwrContent, 3)
			evDialog.render(true);
			break;
		default:
			return;
	}
}

//macro that allows GMs to apply the same exploit vulnerability on a target 
export async function forceEVTarget(){
	const m = await fromUuid(MORTAL_WEAKNESS_TARGET_UUID);
	const p = await fromUuid(PERSONAL_ANTITHESIS_TARGET_UUID);
	let eff;
	
	let a = canvas.tokens.controlled[0];
	let tar = Array.from(game.user.targets);
	let evM = a.actor.getFlag("pf2e-thaum-vuln","EVMode");
	if(evM === "mortal-weakness") {
		eff = m.toObject();
	} else if(evM === "personal-antithesis"){
		eff = p.toObject();
	} else {return}
	eff.system.rules[0].value = a.actor.getFlag("pf2e-thaum-vuln", "EVValue");
	eff.system.rules[1].option = `origin:id:${a.actor.uuid}`;
	eff.name += " (" + a.actor.name + ")";
	for(let targ of tar){
		if(getActorEVEffect(targ.actor)){
			await deleteEVEffect([targ.actor]);
		} else {
			await targ.actor.createEmbeddedDocuments('Item', [eff]);
		}
	}

}

//This is a temporary fix until a later pf2e system update. The function hooks on renderChatMessage attack-rolls
//If the thaumaturge makes an attack-roll, the target's weakness updates with the correct amount
//If it's not the thaumaturge that makes the attack-roll, it changes the weakness to 0
Hooks.on("renderChatMessage", (message) => {
	if(message.speaker.actor && (message.flags?.pf2e?.context?.type === "attack-roll" && canvas.initialized)){
		let a = canvas.tokens.placeables.find(act => act.actor.id === message.speaker.actor).actor;
		if(a.type === "character"){
			updateEVEffect(message.speaker.actor);
		}
	}
},{once:false});

