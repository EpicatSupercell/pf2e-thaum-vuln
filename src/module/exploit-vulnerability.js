import {
  EXPLOIT_VULNERABILITY_ACTION_ID,
  MORTAL_WEAKNESS_EFFECT_SOURCEID,
  MORTAL_WEAKNESS_EFFECT_UUID,
  PERSONAL_ANTITHESIS_EFFECT_SOURCEID,
  PERSONAL_ANTITHESIS_EFFECT_UUID,
  FLAT_FOOTED_EFFECT_UUID,
  MORTAL_WEAKNESS_TARGET_UUID,
  PERSONAL_ANTITHESIS_TARGET_UUID,
  BREACHED_DEFENSES_EFFECT_SOURCEID,
  ESOTERIC_WARDEN_EFFECT_UUID,
  getActorEVEffect,
  createEVDialog,
  BDGreatestBypassableResistance,
  getIWR,
  getGreatestIWR,
  CURSED_EFFIGY_UUID,
} from "./utils.js";
import {
  createEffectOnTarget,
  updateEVEffect,
  deleteEVEffect,
  applySWEffect,
} from "./socket.js";
import "./config.js";
import "./hooks.js";

const SupportedActions = [
  "exploit-vulnerability",
  "share-weakness",
  "cursed-effigy",
];

//Creates the passed effect document on the actor
export async function createEffectOnActor(sa, t, effect, rollDOS) {
  let eff = effect.toObject();
  let evMode;
  let effRuleSlug;
  let effPredicate;
  let EWPredicate;
  let effSlug;
  const useEVAutomation = game.settings.get(
    "pf2e-thaum-vuln",
    "useEVAutomation"
  );
  const hasEsotericWarden = sa.items.some((i) => i.slug === "esoteric-warden");
  const hasSympatheticVulnerabilities = sa.items.some(
    (i) => i.slug === "sympathetic-vulnerabilities"
  );
  let evTargets = new Array();
  if (eff.flags.core.sourceId === MORTAL_WEAKNESS_EFFECT_SOURCEID) {
    EWPredicate = "mortal-weakness-target";
    if (getIWR(t).weaknesses.length === 0) {
      return ui.notifications.warn(
        "There are no weaknesses on this creature to exploit a Mortal Weakness against."
      );
    }
    if (useEVAutomation) {
      evTargets = getMWTargets(t);
      if (hasSympatheticVulnerabilities) {
        evTargets = evTargets.concat(getSVTargets(t, eff));
      }
    }
    effPredicate = `target:effect:Mortal Weakness Target ${sa.name}`.slugify();
    effRuleSlug = "mortal-weakness-effect-magical";
    effSlug = "exploit-mortal-weakness";

    evMode = "mortal-weakness";
  } else if (eff.flags.core.sourceId === PERSONAL_ANTITHESIS_EFFECT_SOURCEID) {
    if (hasSympatheticVulnerabilities && useEVAutomation) {
      evTargets = evTargets.concat(getSVTargets(t, eff));
    }
    EWPredicate = "personal-antithesis-target";
    effPredicate =
      `target:effect:Personal Antithesis Target ${sa.name}`.slugify();
    effRuleSlug = "personal-antithesis-effect-magical";
    evMode = "personal-antithesis";

    //breached defenses logic. It mostly works.... there are a few weird cases where it doesn't work such as when the highest
    //resistance that can be bypassed is a combination of two traits (see adamantine golem's resistance bypass from vorpal-adamantine)
    //or if the trait that bypasses it is not in the system/on my list
  } else if (eff.flags.core.sourceId === BREACHED_DEFENSES_EFFECT_SOURCEID) {
    const ADJUSTMENT_TYPES = {
      materials: {
        propLabel: "materials",
        data: CONFIG.PF2E.preciousMaterials,
      },
      traits: {
        propLabel: "traits",
        data: CONFIG.PF2E.damageTraits,
      },
      "weapon-traits": {
        propLabel: "weapon-traits",
        data: CONFIG.PF2E.weaponTraits,
      },
      "property-runes": {
        propLabel: "property-runes",
        data: CONFIG.PF2E.runes.weapon.property,
      },
    };

    evMode = "breached-defenses";
    effPredicate = [
      `target:effect:Breached Defenses Target ${sa.name}`.slugify(),
    ];
    effRuleSlug = "breached-defenses-bypass";
    const bypassable = BDGreatestBypassableResistance(t);

    //force ghost touch property rune on things that are immune to it
    if (bypassable.exceptions.includes("ghost-touch")) {
      bypassable.exceptions[0] = "ghostTouch";
    }

    const exception = (() => {
      for (const types in ADJUSTMENT_TYPES) {
        if (
          Object.hasOwn(ADJUSTMENT_TYPES[types].data, bypassable.exceptions[0])
        ) {
          return {
            property: ADJUSTMENT_TYPES[types].propLabel,
            exception: bypassable.exceptions[0],
          };
        }
      }
    })();
    eff.system.rules.find(
      (rules) => rules.slug === "breached-defenses-bypass"
    ).value = exception?.exception;
    eff.system.rules.find(
      (rules) => rules.slug === "breached-defenses-bypass"
    ).property = exception?.property;
    eff.system.rules.find(
      (rules) => rules.slug === "breached-defenses-bypass"
    ).predicate = `target:effect:Breached Defenses Target ${sa.name}`.slugify();
    await sa.setFlag("pf2e-thaum-vuln", "EVValue", exception?.exception);
  }
  let EWEffect;
  if (hasEsotericWarden) {
    EWEffect = await fromUuid(ESOTERIC_WARDEN_EFFECT_UUID);
    EWEffect = EWEffect.toObject();
    const bonus = rollDOS === 2 ? 1 : 2;
    EWEffect.system.rules[0].value = bonus;
    EWEffect.system.rules[1].value = bonus;
    EWEffect.system.rules[0].predicate = [
      ("origin:effect:" + EWPredicate + ` ${sa.name}`).slugify(),
    ];
    EWEffect.system.rules[1].predicate = [
      ("origin:effect:" + EWPredicate + ` ${sa.name}`).slugify(),
    ];

    //makes sure a player can't use Esoteric Warden on the same creature twice
    if (
      !sa.getFlag("pf2e-thaum-vuln", "EWImmuneTargs")?.includes(t.actor.uuid)
    ) {
      await sa.createEmbeddedDocuments("Item", [EWEffect]);
    }
    let EWImmuneTargs = new Array();
    EWImmuneTargs = EWImmuneTargs.concat(
      sa.getFlag("pf2e-thaum-vuln", "EWImmuneTargs")
    );
    if (!EWImmuneTargs.some((i) => i === t.actor.uuid)) {
      EWImmuneTargs.push(t.actor.uuid);
    }

    await sa.setFlag("pf2e-thaum-vuln", "EWImmuneTargs", EWImmuneTargs);
  }

  eff.slug = effSlug;
  eff.system.rules.find((rules) => rules.slug === effRuleSlug).predicate =
    effPredicate;
  if (!evTargets.includes(t.actor.uuid)) {
    evTargets.push(t.actor.uuid);
  }
  //makes sure we don't have duplicates in the target array
  evTargets = [...new Set(evTargets)];
  createEffectOnTarget(sa, t, effect, evTargets);

  await sa.setFlag("pf2e-thaum-vuln", "activeEV", true);
  await sa.setFlag("pf2e-thaum-vuln", "EVTargetID", evTargets);
  await sa.setFlag("pf2e-thaum-vuln", "EVMode", `${evMode}`);

  await sa.createEmbeddedDocuments("Item", [eff]);
}

function getSVTargets(t, effect) {
  let targs = new Array();
  if (effect.name.includes("Exploit Mortal Weakness")) {
    for (let token of canvas.tokens.objects.children) {
      if (
        token.actor?.attributes.weaknesses.some(
          (w) => w.type === getGreatestIWR(t.actor.attributes.weaknesses).type
        )
      ) {
        targs.push(token.actor.uuid);
      }
    }
  } else if (effect.name.includes("Exploit Personal Antithesis")) {
    for (let token of canvas.tokens.objects.children) {
      if (token.actor?.name === t.actor.name) {
        targs.push(token.actor.uuid);
      }
    }
  }
  return targs;
}

function getMWTargets(t) {
  let targs = new Array();
  for (let token of canvas.tokens.objects.children) {
    if (token?.actor?.name === t.actor.name) {
      targs.push(token.actor.uuid);
    }
  }
  return targs;
}

export async function exploitVuln() {
  //grab the selected token and the targeted token
  const a = canvas.tokens.controlled;
  let ts = Array.from(game.user.targets);

  //make sure we're only targeting one target and have the thaum selected
  if (a.length != 1 || ts.length != 1) {
    return ui.notifications.warn(
      "Select one Thaumaturge token and target one creature."
    );
  }

  //set the first index in the array as the target and the first controlled token actor as selected actor
  const t = Array.from(ts)[0];
  const sa = a[0].actor;

  //check for exploit vulnerability on the actor
  const exploitVulnAction = sa.items.find(
    (item) =>
      item.getFlag("core", "sourceId") === EXPLOIT_VULNERABILITY_ACTION_ID
  );
  if (!exploitVulnAction) {
    return ui.notifications.warn(
      `${a[0].actor.name} does not have the ability to Exploit Vulnerability`
    );
  }

  //deletes Exploit Vulnerability effect if it already exists on the actor
  await deleteEVEffect(canvas.tokens.placeables, sa);
  let EWEffect = sa.items.find(
    (item) => item.name === "Esoteric Warden Effect"
  );
  if (EWEffect) {
    EWEffect.delete();
  }

  // From https://gist.github.com/stwlam/01c2506e93c298b01ad83c182b245144 by somebody, Supe, and stwlam
  const skill = sa.system.skills["esoteric-lore"];
  if (!skill) {
    return ui.notifications.warn(
      `${sa.name} does not have the Esoteric Lore skill`
    );
  }
  const dc = {
    "-1": 13,
    ...Object.fromEntries(
      Object.entries([
        14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34, 35, 36,
        38, 39, 40, 42, 44, 46, 48, 50,
      ])
    ),
  }[t.actor.level];
  if (!dc) {
    return ui.notifications.warn("No matching DC for target");
  }

  const rollOptions = sa.getRollOptions(["skill-check", skill.slug]);

  const outcomes = {
    criticalSuccess:
      "You remember the creature's weaknesses, and as you empower your esoterica, you have a flash of insight that grants even more knowledge about the creature. You learn all of the creature's resistances, weaknesses, and immunities, including the amounts of the resistances and weaknesses and any unusual weaknesses or vulnerabilities, such as what spells will pass through a golem's antimagic. You can exploit either the creature's mortal weakness or personal antithesis (see below). Your unarmed and weapon Strikes against the creature also become magical if they weren't already.",
    success:
      "You recall an important fact about the creature, learning its highest weakness (or one of its highest weaknesses, if it has multiple with the same value) but not its other weaknesses, resistances, or immunities. You can exploit either the creature's mortal weakness or personal antithesis. Your unarmed and weapon Strikes against the creature also become magical if they weren't already.",
    failure:
      "Failing to recall a salient weakness about the creature, you instead attempt to exploit a more personal vulnerability. You can exploit only the creature's personal antithesis. Your unarmed and weapon Strikes against the creature also become magical if they weren't already.",
    criticalFailure:
      "You couldn't remember the right object to use and become distracted while you rummage through your esoterica. You become flat-footed until the beginning of your next turn.",
  };

  const notes = Object.entries(outcomes).map(([outcome, text]) => ({
    title: game.i18n.localize("PF2E.Check.Result.Degree.Check." + outcome),
    text,
    outcome: [outcome],
  }));

  const hasEsotericWarden = sa.items.some((i) => i.slug === "esoteric-warden");
  if (hasEsotericWarden) {
    notes.push({
      title: "Esoteric Warden",
      text: "When you apply antithetical material against a creature successfully, you also ward yourself against its next attacks. When you succeed at your check to Exploit a Vulnerability, you gain a +1 status bonus to your AC against the creature's next attack and a +1 status bonus to your next saving throw against the creature; if you critically succeed, these bonuses are +2 instead. You can gain these bonuses only once per day against a particular creature, and the benefit ends if you Exploit Vulnerability again.",
      outcome: ["success", "criticalSuccess"],
    });
  }

  const hasDiverseLore = sa.items.some((i) => i.slug === "diverse-lore");
  if (hasDiverseLore) {
    // todo: put npc identify data in the document and then show secret text for it.
    const dc = t.actor.system.details.identification?.skill.dc;
    const diverseLoreDC = dc
      ? `<br/><span data-visibility="gm">Recall Knowledge DC ${dc}</span>`
      : "";
    notes.push({
      title: "Diverse Lore",
      text: `When you succeed at your check to Exploit a Vulnerability, compare the result of your Esoteric Lore check to the DC to Recall Knowledge for that creature; if that number would be a success or a critical success, you gain information as if you had succeeded at the Recall Knowledge check. ${diverseLoreDC}`,
      outcome: ["success", "criticalSuccess"],
    });
  }

  const flavor = `Exploit Vulnerability: ${skill.label}`;
  const checkModifier = new game.pf2e.CheckModifier(flavor, skill);
  const traits = ["esoterica", "manipulate", "thaumaturge"];
  const evRoll = await game.pf2e.Check.roll(
    checkModifier,
    {
      actor: sa,
      target: {
        actor: t.actor,
        token: t.document,
      },
      type: "skill-check",
      options: rollOptions,
      notes,
      dc: { value: dc },
      traits: traits.map((t) => ({
        name: t,
        label: CONFIG.PF2E.actionTraits[t] ?? t,
        description: CONFIG.PF2E.traitsDescriptions[t],
      })),
      flavor: `
    <strong>Frequency</strong> once per round<br/>
    <strong>Requirements</strong> You are holding your implement<br/>
    <hr/>
    <p>You scour your experiences and learning to identify something that might repel your foe. You retrieve an object from your esoterica with the appropriate supernatural qualities, then use your implement to stoke the remnants of its power into a blaze. Select a creature you can see and attempt an Esoteric Lore check against a standard DC for its level, as you retrieve the right object from your esoterica and use your implement to empower it. You gain the following effects until you Exploit Vulnerabilities again.</p>
  `,
    },
    event
  );

  const paEffectSource = await fromUuid(PERSONAL_ANTITHESIS_EFFECT_UUID);
  const mwEffectSource = await fromUuid(MORTAL_WEAKNESS_EFFECT_UUID);
  const flatFootedEffect = await fromUuid(FLAT_FOOTED_EFFECT_UUID);

  let evDialog;
  const rollDOS = evRoll.degreeOfSuccess;
  //Apply effect based on Degrees of success
  switch (rollDOS) {
    case 0:
      //critical failure. Apply flatfooted condition for one round.
      await sa.createEmbeddedDocuments("Item", [flatFootedEffect.toObject()]);
      break;
    case 1:
      //normal failure. Can only apply personal antithesis.
      await createEffectOnActor(sa, t, paEffectSource);
      break;
    case 2:
      //normal success. Learns highest weakness. Can apply Mortal Weakness or Personal Antithesis

      evDialog = await createEVDialog(sa, t, paEffectSource, mwEffectSource, 2);
      evDialog.render(true);
      break;
    case 3:
      //Critical success. Learns all weaknesses, resistances, and immunities including the amounts and any unusual weaknesses or vulnerabilities
      //Can apply Mortal Weakness or Personal Antithesis.
      evDialog = await createEVDialog(sa, t, paEffectSource, mwEffectSource, 3);
      evDialog.render(true);
      break;
    default:
      return;
  }
}

//Share Weakness macro
function shareWeakness() {
  const a = canvas.tokens.controlled;
  const sa = a[0].actor;
  const hasShareWeakness = sa.items.some((i) => i.slug === "share-weakness");
  const hasMortalWeaknessActive = sa.items.some(
    (i) => i.getFlag("core", "sourceId") === MORTAL_WEAKNESS_EFFECT_SOURCEID
  );
  const EVEffect = getActorEVEffect(sa);
  if (!hasShareWeakness) {
    return ui.notifications.warn(
      `${a[0].actor.name} does not have the ability to Share Weakness`
    );
  }
  if (!hasMortalWeaknessActive) {
    return ui.notifications.warn(
      `${a[0].actor.name} does not have a Mortal Weakness effect active`
    );
  }
  const allies = canvas.scene.tokens.filter(
    (token) => token.actor?.alliance === "party"
  );

  const dgContent = $(
    `<div>You select an object from your esoterica that has great personal value to you, such as a locket or treasured ring, and you grant it to an ally, establishing a personal link that allows your ally to affect an enemy as if they were you. The ally's Strikes apply the weakness from your mortal weakness the same way your Strikes do. This benefit ends when your Exploit Vulnerability ends or you Share Weakness again.<br><br>Choose an ally to share your Mortal Weakness effect with.</div>`
  );
  const dgInnerContent = $(
    `<div class="flex-container" style="display: flex; flex-wrap: wrap; justify-content: space-around"></div>`
  );

  let selectedAlly;
  for (let ally of allies) {
    if (ally.actor.uuid != game.user.character.uuid) {
      const allyWrapper = $(
        `<div class="pf2e-ev" style="padding: 0.5rem;"></div>`
      );
      const allyBtn = $(
        `<button style="background: url(${ally.texture.src}); background-size:contain; width:10rem; height:10rem;" class="ally-button" id=${ally.actor.uuid}>`
      );
      const allyName = $(
        `<p style="text-align: center">${ally.actor.name}</p>`
      );

      $(document).ready(function () {
        $(".ally-button").bind("click", function (e) {
          $(".ally-button").css("background-color", "rgba(0,0,0,0)");
          $(e.currentTarget).css("background-color", "red");
          selectedAlly = e.target.attributes.allyuuid.value;
        });
      });

      allyBtn.attr("allyuuid", ally.actor.uuid);
      allyBtn.appendTo(allyWrapper);
      allyName.appendTo(allyWrapper);
      allyWrapper.appendTo(dgInnerContent);
    }
  }
  dgInnerContent.appendTo(dgContent);

  let dgBtns = {
    confirm: {
      label: "Confirm",
      callback: () => {
        applySWEffect(sa.uuid, selectedAlly, EVEffect);
      },
    },
  };

  dgContent.append(dgInnerContent);
  let dg = new Dialog({
    title: "Share Weakness",
    content: dgContent.html(),
    buttons: dgBtns,
    default: "confirm",
    render: () => {},
    close: () => {},
  });

  dg.render(true, {
    width: canvas.dimensions.width / 4,
  });
}

async function cursedEffigy() {
  const t = Array.from(game.user.targets);
  const a = canvas.tokens.controlled[0].actor;
  const hasCursedEffigy = a.items.some((i) => i.slug === "cursed-effigy");

  if (t.length != 1) {
    return ui.notifications.warn(
      "Target only the target of your exploit vulnerability to create a cursed effigy"
    );
  }
  if (!hasCursedEffigy) {
    return ui.notifications.warn(
      "You do not have the ability to create a cursed effigy"
    );
  }
  createEffectOnTarget(a, t[0], await fromUuid(CURSED_EFFIGY_UUID), [
    t[0].actor.uuid,
  ]);
}

//macro that allows GMs to apply the same exploit vulnerability on a target
export async function forceEVTarget() {
  const m = await fromUuid(MORTAL_WEAKNESS_TARGET_UUID);
  const p = await fromUuid(PERSONAL_ANTITHESIS_TARGET_UUID);
  let eff;

  let a = canvas.tokens.controlled[0];
  let tar = Array.from(game.user.targets);
  if (canvas.tokens.controlled.length != 1 || tar.length === 0) {
    return ui.notifications.warn(
      "Select one Thaumaturge token and target one or more creatures"
    );
  }
  let evM = a.actor.getFlag("pf2e-thaum-vuln", "EVMode");
  if (evM === "mortal-weakness") {
    eff = m.toObject();
  } else if (evM === "personal-antithesis") {
    eff = p.toObject();
  } else {
    return ui.notifications.warn(
      "Selected token has not activated Exploit Vulnerability"
    );
  }
  eff.system.rules[0].value = a.actor.getFlag("pf2e-thaum-vuln", "EVValue");
  eff.system.rules[1].option = `origin:id:${a.actor.uuid}`;
  eff.name += " (" + a.actor.name + ")";
  for (let targ of tar) {
    if (getActorEVEffect(targ.actor)) {
      await deleteEVEffect([targ.actor]);
    } else {
      await targ.actor.createEmbeddedDocuments("Item", [eff]);
    }
  }
}

//Creates the button in the chat tile for actions and feats
export async function createChatCardButton(message, html) {
  const actionOrigin = message.flags.pf2e?.origin;

  if (actionOrigin?.type === "action" || actionOrigin?.type === "feat") {
    const user = game.user;
    const speaker = message.actor;
    const action = await fromUuid(actionOrigin.uuid);
    if (SupportedActions.includes(action.slug)) {
      html = html.find(".message-content");
      const contentArea = html.find(".card-content");
      contentArea.append(
        $(
          `<button class='pf2e-ev-feature-btn' ${
            user.character.uuid === speaker.uuid || user.isGM
              ? ""
              : 'style="visibility:hidden"'
          } title="Use Feature">Use ${action.name}</button>`
        ).on({
          click: () => {
            executeAction(action);
          },
        })
      );
    }
  }
}

function executeAction(action) {
  switch (action.slug) {
    case "exploit-vulnerability":
      exploitVuln();
      break;
    case "share-weakness":
      shareWeakness();
      break;
    case "cursed-effigy":
      cursedEffigy();
      break;
    default:
      break;
  }
}
//removes the corresponding option from Esoteric Warden. If the thaum is targeted with
//a strike, they lose the AC bonus. If they are targeted with a save, they lose the save
//bonus
export async function removeEWOption(EWEffect, t, choice) {
  const tKey = EWEffect._id;
  const EWRule1 = EWEffect.system.rules[0];
  const EWRule2 = EWEffect.system.rules[1];
  let updates = {
    _id: tKey,
    system: {
      rules: [
        {
          key: EWRule1.key,
          selector: EWRule1.selector,
          value: EWRule1.value,
          type: EWRule1.type,
          slug: EWRule1.slug,
          predicate: EWRule1.predicate,
        },
        {
          key: EWRule2.key,
          selector: EWRule2.selector,
          value: EWRule2.value,
          type: EWRule2.type,
          slug: EWRule2.slug,
          predicate: EWRule2.predicate,
        },
      ],
    },
  };
  if (choice === "ac" && EWEffect.system.rules[0].value != 0) {
    updates.system.rules[0].value = 0;
  } else if (choice === "save" && EWEffect.system.rules[1].value != 0) {
    updates.system.rules[1].value = 0;
  }
  if (
    updates.system.rules[0].value === 0 &&
    updates.system.rules[1].value === 0
  ) {
    EWEffect.delete();
  } else {
    if (t.actor) {
      t = t.actor;
    }

    await t.updateEmbeddedDocuments("Item", [updates]);
  }
}
